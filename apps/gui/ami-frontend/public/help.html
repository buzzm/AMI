<HTML>

  <HEAD>
<TITLE>AMI Guide</TITLE>

<style type="text/css">
.QQQ {
   background-color: #CCFFCC ; 
   margin-left: 20pt ;
   margin-right: 160pt ;
}
.ZZZ {
   margin-left: 20pt ;
}

.rev {
   font-size: 12 ; 
}

.indented-block {
    margin-left: 20px; /* Adjust the value to control the amount of indentation */
    /* Alternatively, you can use padding if you prefer */
    padding-left: 20px;
}

</style>
</HEAD>


  <BODY>
<H1>AMI Guide</H1>

<H2>TL;DR</H2>
Type each of the following lines separately into the input box followed by GO:
<ol>
  <li>Show me all my software and vendor names.</li>
  <li>Group by vendor name and show me totals.</li>
  <li>Just the top 3.</li>
  <li>(Stash the data)</li>
  <li>Describe the relationship between AMI Software and AMI Components.
</ol>

<H2>Contents</H2>
<ol>
  <li><a href="#overview">Overview</A></li>
  <li><a href="#simple">Getting started with The Simple Domain</A></li>
  <li><a href="#cheat">AMI Cheat Sheet</A></li>    
</ol>


<A NAME="overview"></A>	 
<H3>Overview</H3>
Asset Management & Intelligence (AMI) is a hybrid AI/configuration management
database ("CMDB") that allows you to explore your technology footprint both
conversationally and programmatically.
The backend CMDB contains your information on
software, hardware, data shapes, vendors, and more and is precisely and reliably
queryable using SPARQL, much in the same way Oracle or Postgres can be precisely
and reliably queried using SQL.   By "precisely and reliably" we mean that
queries work the same way each time, every time.   There are no hallucinations.
But building such queries can be tedious and furthermore, there is a great
deal of interesting and relevant information on the internet that is clearly
not part of your CMDB.   AMI uses a novel approach to use a carefully prompted
LLM to generate SPARQL to access your data and can then blend that with other
information, at your discretion, in a general purpose LLM.  
<p>
  AMI responds to different "flavors" of questions as follows:
  <ol>
    <li>Questions it can reasonably infer are associated directly with specific
      CMDB data.  Example: "Show all my software that is going EOL
      in 2024."  AMI knows about the concept of "Software" and "EOL" in its
      metadata and together with the word "my", AMI will construct SPARQL, 
      call the CMDB, and display the results in tabular form.
    </li><br>
    <li>Questions that are ambiguous regarding association with local CMDB
      data or the general knowledge pool:  Example:  "What is the most
      popular software?" or "What software uses log4j?"  AMI can come up with
      a variety of interpretations and the user must be vigilant to review
      the narrative and possibly SPARQL response.  Just 1 or 2 extra words
      or punctuation will significantly help AMI, e.g. <tt>What software in my
      catalog uses dd:log4j?</tt> will certainly generate a SPARQL/CMDB result.
    </li><br>
    <li>Questions that clearly cannot be answered by the AMI CMDB.  Example:
      "What are the corporate headquarters for my vendors?" or "What is the
      diameter of the moon?"
    </li>
  </ol>
  The key concept to bridging the data is through the use of <b>stashing</b>.
  Of course, upon startup if you so desired, you can certainly begin an AMI
  engagement with "What is the diameter of the moon?" which the backend will clearly
  vector to the general purpose LLM ; no SPARQL here!  But the more common use
  is to ask CMDB-targeted questions, get data results, and then add this data
  to the LLM via stashing.   Stashing is made to be an optional step because
  especially as you are iteratively enhancing a question/query, it doesn't
  help the LLM to keep ingesting intermediate stages of data.  When you are
  pleased with the progress, then it's time to stash the results.
</p>  


<A NAME="simple"></A>	 
<H3>The Simple Domain and Basic AMI Concepts</H3>
The Simple Domain is the "training ground" for AMI.  It allows you to explore
these important interaction concepts:
<ul>
  <li>The incrementally iterative UI/UX of AMI i.e. you can use just a few words to
    enhance the results of the previous query.</li>
    
  <li>The relationship between the <tt>ami:Software</tt> and <tt>ami:Component</tt>
    classes.</li>
    
  <li>The ability of AMI to answer questions about itself ("self-documentation")</li>
    
</ul>
<p>
  The raw data backing the simple domain can be
  <a href="simple_data.ttl">viewed here</a>; note that actual data being queried
  by SPARQL is in a real triplestore.  But let's start using the GUI.
  In the input window, type:
  <div class="QQQ"><pre>
      List all owner and steward names.
  </pre></div>
  This is a fairly wide open query but AMI has been conditioned to be extra
  sensitive to the words owner and steward and you should get back a table listing
  Steve and Dave as owner and steward.
  Note that the SPARQL used to generate the data appears in the conversation.
</p>
<p>
  Here is tip #1:  Don't assume AMI will give you more than what you asked for.
  The query gave you exactly what you asked for -- and we don't know what assets
  Dave and Steve own/steward.<br>
  Which leads to tip #2:  Think about incremental refinement of what you are
  looking for.  Try this in the input window:
  <div class="QQQ"><pre>
      Keep the current output but add a description of the item.
  </pre></div>
</p>

<p>
  Tip #3:  If you want to "change direction", help AMI by explicitly stating
  to start over:
  <div class="QQQ"><pre>
      Reset the conversation.
  </pre></div>
</p>

There are two general approaches to interrogating AMI:
<ol>
  <li>Top-down from System level e.g. "What is in System X?".  This is popular
    because IT assets are often organized by system to facilitate understanding
    of function and a common set of terms for IT And the business to share.</li>
  <li>Bottom-up from Software e.g. "What depends on Oracle?".  This is popular
    because understanding dependency chains greatly aids risk management
    and strategic transformation</li>  
</ol>

Let's start with a top-down approach.
  <div class="QQQ"><pre>
      List all AMI systems.
  </pre></div>
  The simple domain has one system, "Hello World."  Let's find the components
  of that system:
  <div class="QQQ"><pre>
      Show me all Components of AMI system dd:sy2iu3uy.
  </pre></div>  
  The hello world Component appears in the data output area.
  Tip #4:  If you are dealing with specific items like a particular system or
  component or piece of software, it greatly helps AMI generate a good query if
  you use the entity ids e.g. <tt>dd:sy2iu3uy</tt>.  However, in the cases
  where the context/intent is very clear, the conversational nature of AMI
  will work too, as follows:
  
  <div class="QQQ"><pre>
  What AMI software is used in these components?
  </pre></div>  
  The data table will show <tt>dd:sw0r5i28</tt> which is actual piece of
  software.

  <div class="QQQ"><pre>
Tell me everything about dd:sw0r5i28
  </pre></div>
  Coming back to tip #1, the data output does not recursively dig through
  the Actor or Version objects.   Let's add that now:


  <div class="QQQ"><pre>
      Keep all the output except expand ami:version for all its fields,
      and expand ami:steward and ami:owner to include names.
  </pre></div>
  It is highly likely that AMI has made a mistake here and interpreted
  "expand" to mean some sort of a union-like operation.   Let's go back:
  <div class="QQQ"><pre>
      That is not correct.  Please revert to the prior query.
  </pre></div>
  OK.  Let's try a more direct query:
  <div class="QQQ"><pre>
      Good.  Please show owner and steward names and version detail for dd:sw0r5i28.
  </pre></div>
  <div class="QQQ"><pre>
Keep the current output and add ami:slang.
  </pre></div>
  Now, let's stash this data.   Press YES under the data output and this should
  appear in the conversation window:
  <pre class="indented-block">
Got it! I've noted the output as dataset 1. If you need to refer to it or have any questions, just let me know!
    </pre>

  <div class="QQQ"><pre>
Can you tell me anything interesting about dataset 1?
  </pre></div>
  AMI is now in "general LLM mode" and will attempt to create narrative and
  should produce something like this:
  <pre class="indented-block">
Dataset 1 includes information about a technology asset with the following details:

- **Owner Name**: Steve Austin
- **Steward Name**: Dave Spector
- **Version**: Major version 8, Minor version 2, Patch version 3
- **Binary Type**: x86_64
- **Release Date**: January 1, 2006
- **Slang**: c

An interesting aspect is that the slang "c" likely refers to the C programming language, which is 
known for its efficiency and is widely used in system programming. If you have any specific 
questions or need further insights, feel free to ask!
</pre>

Let's dig deeper on that insight:
  <div class="QQQ"><pre>
What is the future of the C programming language?
  </pre></div>  
  <pre class="indented-block">
The future of the C programming language looks promising, despite the emergence of many newer 
languages. Here are a few key points about its future:

1. **Legacy Systems**: C is deeply embedded 
in many legacy systems, especially in operating systems, embedded systems, and high-performance 
...    
  </pre>


  
<H4>Software and Components</H4>
<p>
  In the AMI information architecture, <b>Software</b> is defined as versioned release
of a thing. 
  <div class="QQQ"><pre>
      List all AMI Software.
  </pre></div>
  Again note that we hint to the LLM that it is the AMI domain of software we
  are interested in, not <i>all</i> the software it knows about (which is a lot).
</p>
<p>
  <div class="QQQ"><pre>
      List all AMI Components.
  </pre></div>  
  A <b>Component</b> is an (ultimately) executable thing that presents interfaces
  to which other Components may connect, and it declares the Components upon which
  it depends.   Whereas Software is mostly concerned with version, vendor, and
  compile and runtime dependencies, Components are more concerned with data flow.
  A crucial connection between Software and Components is the <tt>entryPoint</tt>
  property of Component.  
</p>
<p>
  <div class="QQQ"><pre>
      What is an AMI Component?
  </pre></div>  
  AMI is a self-documenting system.  The definition of the classes and the
  labels and comments therein -- essentially, the AMI metadata -- can be examined
  by the LLM to produce textual answers.
</p>




<A NAME="cheat"></A>	   
<H3>AMI Information Architecture Cheat Sheet</H3>
<P>
  Essential properties:
  <ul>
    <li><tt>ami:owner</tt><br>
      The <tt>ami:owner</tt> is the administrative manager of a thing, typically a
      manager in the IT department.  The owner is responsible for the correct
      information associated with a thing.  The owner can also be the steward and
      visa versa.  The owner is not as important from a functional perspective as
      the steward.
    </li><br>
    <li><tt>ami:steward</tt><br>
      The <tt>ami:steward</tt>
      is the operational manager of a thing, typically a developer or DBA or
      perhaps someone in a release/monitoring role.
      It is important to differentiate that the steward is tasked with the
      operational update of a thing but it is the
      owner that is ultimately responsible for the correct information.
      The steward is the most important Actor engaged with a thing because it is
      assumed that they actually know how it works.
      The steward can of course also be the owner and visa versa.  
    </li><br>    
    <li><tt>rdfs:label</tt><br>
      The <tt>rdfs:label</tt> property
      is an industry-recognized (very) terse description of a thing.  It is
      very important within the AMI framework because it acts as a tag
      and helps the AI/LLM "home on things" in a general way.
    </li><br>
    <li><tt>rdfs:comment</tt><br>
      The <tt>rdfs:comment</tt> property
      is an industry-recognized verbose description of a thing.  Arguably,
      for open-ended discovery of material within AMI, the <tt>rdfs:comment</tt>
      property is the most important because the verbosity helps the AI/LLM
      select candidate material.  At a minimum, <tt>rdfs:comment</tt> should be
      the same value as <tt>rdfs:label</tt> but ideally it is <i>much</i> more
      verbose
    </li><br>
    <li><tt>ami:linksWith</tt><br>
    </li><br>
    <li><tt>ami:connectsTo</tt><br>
    </li><br>        
  </ul>
</p>

Mainline Classes:
<ul>
  <li>Software is versioned unit of release of something like <tt>log4j</tt> or <tt>postgres 16.3</tt>.</li>
  <li>Software has a property <tt>linksWith</tt> whose values are also Software; this enables
    AMI to create a dependency chain, both up and downstream.
  </li>  
  <li>Components are logical building blocks for systems.  Components declare interfaces
    and the protocols and shapes of data that pass through them.  They also declare
    other Components upon which they depend via the <tt>connectsTo</tt> property; this
    enables AMI to create a dependency chain, both up and downstream.
  </li>
  <li>Hardware is a specification for a platform that can run Components; it is not the
    actual running instance.  Virtual machines are considered Hardware.
  </li>
  <li>A Runner is an activated instance of Hardware.  Many active instances can refer
    to the same Hardware spec e.g. 10 instances of AWS <tt>t2.medium</tt>.
  </li>
  <li>An Exec is a running Component on a Runner.  This is the "top" of the AMI information
    architecture.
  </li>
</ul>  

Management/Administrative Classes:
<ul>
  <li>A System is a named set of at least one Component.  A System provides
    context to the business and IT i.e. it is a reference point for some domain
    of activity.
    A System does not need to name all dependent Components; almost always it is
    only the top-most Components like GUI applications that are listed.  All
    downstream dependencies are derived from transitive closure on the
    Component <tt>connectsTo</tt> property.
    Because Systems are basically just labels, they can overlap e.g.
    System A contains components X, Y, and Z and System B contains X.
    Systems have department and other administrative properties which make
    them typically the starting point for inquires e.g. "What systems do
    I have that use Oracle 12?"
  </li>
  <li>An Actor is an entity that engages with resources managed by AMI.
    Actors can be real people or system processes.  The <tt>ami:owner</tt>
    and <tt>ami:steward</tt> properties appear in all mainline classes
    and are vital for analyzing who is interacting with the technology
    footprint and how.
  </li>
  <li>The Control class contains properties of the overall AMI system
    itself.
  </li>
</ul>

The Shape Class:
<ul>
  <li>Shapes are special because they inherit from the industry standard spec
    called SHACL.  Shapes are also significantly more rich in structure
    than the more scalar property oriented Software and Hardware classes.
  </li>
</ul>

Other Classes:
<ul>    
  <li>Version</li>
  <li>MEP</li>  
</ul>


<H3>Self-Documentation and The Power of LLM</H3>
RDF hyperdenormalization gives us the opportunity to label and comment every
single property in every single entity.  Even the most terse creation of
labels and comments, combined with LLM, allows us to ask:

  What properties are associated with sensitive data?





<H3>Important Tips When Querying AMI</H3>
When AMI generates SPARQL, that SPARQL if executed over and over, will produce
the same results every time.  However, it is possible that in trying to make
a SPARQL query, AMI will misinterpret what you wanted and produce a different
query that may yield different answers than you expect.  For example  if you
are asking for system descriptions hoping to get the rdfs:comment field for
each instance of an AMI System class, occasionally your conversation context
will trigger the LLM to instead fashion SPARQL that include the
ami:systemdesc property because it has an rdfs:label of "system description".




<H3>Entities in AMI</H3>
<p>
  AMI primary keys (the subjects)
  are essentially internal only.
  To add a bit of context to what they are, AMI subject and objects in the
  actual data domain (not the metadata domain) have a formula for
  their construction:  <tt>  dd:[entity_type][random] </tt>.  The
  entity type is one of the following:
  <ul>
    <li>sf   Software</li>
    <li>hr   Hardware</li>
    <li>sh   Shape</li>
    <li>co   Component</li>
    <li>sy   System</li>
    <li>in   Instance</li>
    <li>vn   Vendor</li>
    <li>ac   Actor</li>
    <li>ve   Version</li>
    <li>rp   Report</li>                                    
  </ul>
  The <i>random</i> is a 6 character code of the form
  <tt>[0-9][a-z0-9]{2}[0-9][a-z0-9]{2}</tt>.  This permits up to 167,961,600
  unique codes without the danger of creating off-color words
  Examples: <tt>  6un6wm, 1pw5yj, 62l3mo, 06180o, 639423, 2qt4uu </tt>

  <div class="QQQ"><pre>
dd:2qt4uu	a		ami:Software ;
	ami:version [ a ami:Version; ami:major 2; ami:minor 8; ami:bintype "jar" ];
	rdfs:label "log4j";
	rdfs:comment "Extremely popular logging framework for Java" ;		
</pre></div>

  The numeric-infused randomness also helps the LLM clearly distinguish
  keys from other text.


  </BODY>
</HTML>

	      



