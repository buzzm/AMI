@prefix ami: <http://moschetti.org/ami#> .

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .


ami:Actor a rdfs:Class ;
	  rdfs:comment """
An Actor is someone or something that interacts with entities in AMI.  An
Actor can be a person or an automated program; it is not a group role.
Details of the properties of Actor are associated with the properties
themselves.
""" .

ami:Version a rdfs:Class ;
	  rdfs:comment """
Version is an abstraction that allows us to more precisely manage the
version number and binary type for an entity.  For example, a single entity commonly
known as "java" (and in fact so marked in AMI RDF as rdfs:label "java") will have many
unique Software triples, one for each combination of version
(e.g. 11.1, 11.3, 17.2, 21.4, etc.) and binary build types
e.g. win32, arm64, x86_64, etc.
The Version class allows us to better handle missing components like minor or
patch number and avoids consumers have to parse potentially unwieldly strings like
"java-17.0.11-SNAPSHOT-arm64".
Note that unlike the java JVM runtime, java jar libraries are platform independent;
therefore, the binary type for instances of jars is always simply "jar".
""" .

#  Versionable/owned things are Items:
ami:Item a rdfs:Class ;
	  rdfs:comment """
The Item is a foundational class in AMI.  Almost all other entity type in AMI
are subclasses of Item.  Item properties are used for managability and
system maintenance e.g. ownersip, versioning, timestamping, etc.
More details of the properties of Item are associated with the properties
themselves.
""" .

#  Concept for future with inference turned off: explicit dual inheritance:
#ex:program1 a ami:Software, ami:Item ;




#
#  The Core Classes
#
ami:Software a rdfs:Class;
    rdfs:subClassOf ami:Item ;
    rdfs:comment """
Software is any kind of unit of release of (ultimately) executable software.
Software can be a Java .jar file, a Windows .exe program, a shared library
like libc.so, a tomcat .war file, a python module like pandas, a database
engine like Oracle or MongoDB, or a message bus like Kafka.
AMI is not a software development and versioning
platform; therefore, it is not granular to individual source code files.
An important property of Software is "implements" which declares the Software
to have a particular Component as its interface.
""" .

ami:Hardware a rdfs:Class;
    rdfs:subClassOf ami:Item ;
    rdfs:comment """
Hardware is any kind of unit of release of (ultimately) an execution platform.
Hardware can be physical or virtual.  Hardware can be a virtual machine,
an 8 processor on-prem server, a router, a file system, a storage device,
or a network, for example.  We distinguish hardware from software (even though
virtual machines are software) because common design idioms focus on different
capabilities, scalability, costs, and support for each.
An important property of Hardware is "implements" which declares the Software
to have a particular Component as its interface.
""" .

ami:Shape a rdfs:Class;
    rdfs:subClassOf ami:Item ;
    rdfs:comment """
A Shape is the definition of an arbitrarily complex record of data.  A Shape
can be a single scalar or a complex, multi-level assembly of structures and
arrays.  AMI Shapes are somewhat special in that they are instances of both
ami:Shape and the SHACL sh:NodeShape classes (e.g. multiple inheritance).
This permits the AMI system to manage the Shapes consistently with Software
and Hardware and other types but the overall definition framework is SHACL.
This permits industry standard tooling to work with Shapes.
Shapes only define structure and field documentation, *not* validation
constraints.
This is important because 2 or more Components sharing a Shape may have
different validation requirements.
""" .

ami:Component a rdfs:Class;
    rdfs:subClassOf ami:Item ;
    rdfs:comment """
A Component is an abstract description of a service that interacts with
other components according to zero or more message exchange patterns.  A
component does not specify software or hardware.  Components can name
other components that they require to perform their function but do not
name the components that connect to them; rather, they advertise their interface
in terms of connection protocol, authentication, and data shapes consumed
and returned.  Applications, databases, web services, message busses, load
balancers, and bucket storage are all components.  
""" .


ami:System a rdfs:Class;
    rdfs:subClassOf ami:Item ;
    rdfs:comment """
A System is named collection of one or more components.  It is not necessary
for a system to define all the components upon which it depends.  A simple
example is a system could contain a single application component.  The AMI
engine can then use the component definitions to recursively name all
"downstream" dependencies.  Systems also have a number of administrative
properties to facilitate management including department and audit information.
Business users understand the business purpose of systems, not individual
components and certainly not software or hardware.
""" .

ami:Vendor a rdfs:Class;
    rdfs:subClassOf ami:Item ;
    rdfs:comment """
A Vendor is a supplier of software, hardware, or data.  Vendors are not Actors.
Actors are entities that interact directly with the technology whereas Vendors
are suppliers.  Actors have entitlements require authentication; Vendors do not.
""" .

ami:Instance a rdfs:Class;
    rdfs:subClassOf ami:Item .



    
#
#  Common Properties
#  In RDF, properties are defined "outside" a class and associated with one
#  OR MORE of them using the rdfs:domain predicate.
#  Although this seems a little awkward, esp. for those accustomed to
#  properties and attributes being defined *inside* a class as in Java e.g.
#    class A {
#        private String property1;
#        private int property2;
#    }
#  the RDF approach is much more "semanticly friendly" as it creates commonality
#  of definition and use across classes.





#
#  Actor Properties
#
ami:DID a rdf:Property;
    rdfs:domain ami:Actor;
    rdfs:range xsd:string.

ami:firstname a rdf:Property;
    rdfs:domain ami:Actor;
    rdfs:range xsd:string.

ami:lastname a rdf:Property;
    rdfs:domain ami:Actor;
    rdfs:range xsd:string.

#
#  Vendor Properties
#
ami:LEI a rdf:Property;
    rdfs:label "legal entity identifier" ;
    rdfs:comment "Populated from somewhere" ;
    rdfs:domain ami:Vendor;
    rdfs:range xsd:string.


#
#  Item Properties
#
ami:owner a rdf:Property;
    rdfs:domain ami:Item;
    rdfs:range ami:Actor;
    rdfs:comment """
owner is the administrative manager of an Item, typically a manager in
a department.  The owner is responsible for the correct information associated
with an Item.  The owner can also be the steward and visa versa.  The owner
is not as important from a functional perspective as the steward.
""" .

ami:steward a rdf:Property;
    rdfs:domain ami:Item;
    rdfs:range ami:Actor;
    rdfs:comment """
steward is the operational manager of an Item, typically a developer or DBA.
The steward is tasked with the operational update of the Item but it is the
owner that is ultimately responsible for the correct information.
The steward is the most important Actor engaged with an Item because it is
assumed that they actually know how it works.
The steward can also be the owner and visa versa.  
""" .

ami:vers a rdf:Property;
    rdfs:domain ami:Item;
    rdfs:range xsd:int.

ami:created a rdf:Property;
    rdfs:domain ami:Item;
    rdfs:range xsd:dateTime ;
    rdfs:comment """
created is a low-level AMI system field.  It is the timestamp of when
the entity was physically stored in AMI.
""" .

ami:createdBy a rdf:Property;
    rdfs:domain ami:Item;
    rdfs:range ami:Actor;
    rdfs:comment """
createdBy is a low-level AMI system field.  It is the Actor that actually
created the physical Item in the AMI system. createdBy will almost always be
a system process Actor.  For most questions, createdBy is the least important of
the Actor ranged properties.  It is possible that createdBy can be the same
as owner and steward.
""" .    

#
#  Version
#
ami:major a rdf:Property;
    rdfs:domain ami:Version;
    rdfs:range xsd:int.
ami:minor a rdf:Property;
    rdfs:domain ami:Version;
    rdfs:range xsd:int.
ami:patch a rdf:Property;
    rdfs:domain ami:Version;
    rdfs:range xsd:int.
ami:alpha a rdf:Property;
    rdfs:domain ami:Version;
    rdfs:range xsd:string.
ami:released a rdf:Property;
    rdfs:domain ami:Version;
    rdfs:range xsd:dateTime.

ami:bintype a rdf:Property;
    rdfs:label "binary type" ;
    rdfs:comment """
"x86_64" and "jar" are two common binary file types.  Note that "python" is also
a valid type even though technically it is not binary.""" ;
    rdfs:domain ami:Version ;
    rdfs:range xsd:string .

ami:platform a rdf:Property;
    rdfs:label "platform" ;
    rdfs:comment """
A platform encompasses hardware, software, and a user engagement experience.  The term is most
closely associated with mobile device technology.  "Android" and "iOS" are very well known
platforms. """ ;
    rdfs:domain ami:Version;
    rdfs:range xsd:string.    


#
#  Common properties for Software, Hardware, and Shape:
#  
ami:version a rdf:Property;
    rdfs:domain ami:Software, ami:Hardware, ami:Shape ;
    rdfs:range ami:Version.

#
#  Common properties for Software and Hardware:
#  

ami:vendor a rdf:Property;
    rdfs:domain ami:Software, ami:Hardware;
    rdfs:range xsd:string.
ami:EOL a rdf:Property;
    rdfs:domain ami:Software, ami:Hardware;
    rdfs:range xsd:dateTime;
    rdfs:comment """
EOL is an acronym for "end of life."  It is a date at which a thing typically
loses official support.  In particular, using software past EOL increases
the risk of security vulnerabilities not being fixed and decreasing
compatibility with other software.
""" .    

ami:linksWith rdf:type rdf:Property ;
              rdfs:domain ami:Software ;
              rdfs:range ami:Software ;
              rdfs:label "links with" ;
              rdfs:comment "Links this software with another software." .

ami:swtype rdf:type rdf:Property ;
           rdfs:domain ami:Software ;
           rdfs:range xsd:string ;
	   rdfs:label "software type" ;
	   rdfs:comment """
It is often helpful to characterize
software according to how it is used.
"app", "service", "daemon", and "lib" are common Software ami:swtypes.
"app" a.k.a. application means something that a users sees and interacts with.
"service" and "daemon" mean something that is started by automated processes and
continues to run "in the background", waiting to perform tasks, typically for
applications.
Databases, web services, and message busses are specialized examples of services.
"lib" a.k.a. library is releasable unit of code like log4j-core-2.17.1.jar.
""" .


ami:implements rdf:type rdf:Property ;
               rdfs:domain ami:Software , ami:Hardware ;
               rdfs:range ami:Component ;
               rdfs:label "implements" ;
               rdfs:comment """
Optionally indicates the component i.e. the logical interface that this software
implements.  Typically but not exclusively, this property exists on top-level
executables like servlet subclasses, engines like message busses, etc.
""" .


#
#  Component field defs
#
ami:listensFor rdf:type rdf:Property ;
               rdfs:domain ami:Component ;
               rdfs:range rdf:List ;  # Assuming the value is a structured list
               rdfs:label "listens for" ;
               rdfs:comment "Defines the protocols and message exchange patterns that the component listens for." .

# Define the ami:protocol property
ami:protocol rdf:type rdf:Property ;
             rdfs:domain rdf:List ;  # Typically part of a structured list in the listensFor property
             rdfs:range ami:Protocol ;  # Assuming Protocol is a class
             rdfs:label "protocol" ;
             rdfs:comment "Specifies the protocol used by the component (e.g., HTTPS)." .

# Define the ami:auth property
ami:auth rdf:type rdf:Property ;
         rdfs:domain rdf:List ;  # Part of the structured list in the listensFor property
         rdfs:range ami:Auth ;  # Assuming Auth is a class
         rdfs:label "authentication" ;
         rdfs:comment "Specifies the authentication method used by the component (e.g., Basic)." .

# Define the ami:shapeIn property
ami:shapeIn rdf:type rdf:Property ;
            rdfs:domain rdf:List ;  # Part of the structured list in the listensFor property
            rdfs:range ami:Shape ;  # Shape expected as input
            rdfs:label "shape in" ;
            rdfs:comment "Defines the input data shape that the component expects." .

# Define the ami:shapeOut property
ami:shapeOut rdf:type rdf:Property ;
             rdfs:domain rdf:List ;  # Part of the structured list in the listensFor property
             rdfs:range ami:Shape ;  # Shape expected as output
             rdfs:label "record or table or document" ;
             rdfs:comment """
Defines the output data shape that the component produces.
A broad-based use of ami:shapeOut is to have it describe all the tables or collections
in a database component.
""" .

# Define the ex:mep1 and ex:mep2 properties as blank nodes within the list
# Assuming these are part of the structured listensFor property

# Define the ami:connectsTo property
ami:connectsTo rdf:type rdf:Property ;
               rdfs:domain ami:Component ;
               rdfs:range ami:Component ;  # Connecting to another component/service
               rdfs:label "connects to" ;
               rdfs:comment "Specifies another component or service that this component connects to." .

#
#  System Properties
#
ami:components rdf:type rdf:Property ;
               rdfs:domain ami:System ;
               rdfs:range ami:Component ;  # Refers to individual Component instances
               rdfs:comment "A component that is part of the system. Multiple instances of this property can be used for different components." .

ami:dept rdf:type rdf:Property ;
         rdfs:domain ami:System ;
         rdfs:range xsd:string ;
	 rdfs:label "department" ;
         rdfs:comment """
A department is an organizational code.  AMI places no restriction on the value.
It is used for grouping and querying only. """ .


ami:macrotype rdf:type rdf:Property ;
         rdfs:domain ami:System ;
         rdfs:range xsd:string ;
	 rdfs:label "macroscopic type" ;
         rdfs:comment """
Systems are given very high level characterizations to help people
better coarsely understand some of the technology used within.
"mainframe", "distributed", and "desktop" are common System ami:macrotypes.
""" .
