
# ami is the model, buzz is "my data"
# Make sure the ami5 collection _id = SCHEME has a prefixes entry
# that matches these!
PREFIX ami: <http://moschetti.org/ami#>
PREFIX dd: <http://moschetti.org/buzz#>

PREFIX exc: <http://moschetti.org/compliance#>

PREFIX sh: <http://www.w3.org/ns/shacl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

PREFIX xts: <http://xts.com/xts#>

# SELECT ?component
# WHERE {
#   ?system a ami:System ;
#           ami:components ?initialComponent .
  
#   # Recursively find all components connected via 'ami:connectsTo'
#   ?initialComponent (ami:connectsTo)* ?component .

#   # Step 2: Find components that are not in the set of connected components
  
# #  FILTER NOT EXISTS {
# #    ?system a ami:System ;
# #            ami:components ?initialComponent2 .
# #    ?initialComponent2 (ami:connectsTo)* ?component .
# #  }

## SPARQL
# This query retrieves all components that use the specified AMI Shape.
# It checks for the shape in both shapeIn and shapeOut properties of MEPs.
SELECT ?component ?label ?mep
WHERE {
      {
      dd:myShape_001 ami:shapeIn ?mepEntry .
          ?mepEntry ?mep ?component .

      # Get the label for the component
          ?component rdfs:label ?label .
  } UNION {
    dd:myShape_001 ami:shapeOut ?mepEntry .
    ?mepEntry ?mep ?component .

    # Get the label for the component
    ?component rdfs:label ?label .
    }
}




# SELECT ?desc ?owner ?dept ?ownerName ?steward ?stewardName
# WHERE {
#     ?system a ami:System ;
#             ami:systemdesc ?desc ;
#             ami:dept ?dept ;
#             ami:owner ?owner ;
#             ami:steward ?steward .
#     ?owner rdfs:label ?ownerName .
#     ?steward rdfs:label ?stewardName .
# }


# #SELECT ?software ?released ?eol (?eol - ?released AS ?daysDifference)
# #SELECT ?software ?released ?eol (xsd:decimal(?eol - ?released) AS ?diff)

# #SELECT ?software ?released ?eol ((xsd:dateTime(?eol) - xsd:dateTime(?released)) / (60*60*24) AS ?daysDifference)

# SELECT ?software ?released ?eol ((xsd:dateTime(?eol) - xsd:dateTime(?released)))

# WHERE {
#     ?software a ami:Software ;
#     	      ami:EOL  ?eol ;
#     	      ami:version ?vers .

#     ?vers     ami:released	?released ;

# }
# ORDER BY DESC(?eol - ?released)
# LIMIT 3


